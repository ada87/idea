<html>
<head>
<meta charset="UTF-8">
<title>Sudoku 演算</title>
</head>

<script>
var Sudoku = function(coords){
	this.init(coords);
}

Sudoku.prototype = {
	_H:0,_V:1,_T:2,HEIGHT:9,
	maxCount:2,completeCount:0,
	cols:[],maybe:[],_defaultcols:[],
	//开始运算,
	//再说一下，此程序很难理解，因为用了一些JavaScript的默认转换的特性，所以里面有很多字符串与数字相加，比较的计算，在其它语言里面是不允许的，在JavaScript用太多也不好，大家不要学我，看的时候略过这些不规范。
	reckon:function(){
		console.time('Time for all count');
		//整理数据,可计算出一眼就能看出的数据
		this.clearData();
		//开始计算
		this.count();
		console.timeEnd('Time for all count');
	},
	/**
	*递归算法，由于第二次的开始运算的数据基于第一次运算的结果，直到全部运算完成或超过预置的最大运算次数
	*	运算包括三个阶段，运行完后整理数据，如果尚未计算完，则以此次的结果再重新计算一次
	*	1.计算行、列、宫内，可以完全确定的数字。比如 40 62 13 26 都为数字 1 则可以确定 01 位肯定就是数字1
	*	2.推导根据 水平和垂直的宫，去推导数据，比如上三宫的两宫的一二行都有数字 1，第三行只有一个空位，那肯定也是数字1
	*	3.反向推导 （正在开发中，需要假设位，目前正在考虑比较高效的算法，挑战下自己）比如一个空位可能是 1或2，则假设为1或2 是否能使其它的行列宫不成立，如果假设的2不成立，则此号位就是 1	
	*
	*/
	count:function(){
		if(this.completeCount>=this.maxCount){
			this.showResult();
			return;
		}
		console.time('Count'+this.completeCount+' for reckon');
		//阶段一：算出能够肯定的数据
		this.setSingleData();
		//阶段二：简单推导
		this.deduce();
		console.timeEnd('Count'+this.completeCount+' for reckon');
		this.completeCount++;
		this.count();
	},
	//根据目前已知的数据初步进行整理，将可能的数据理顺
	/**
	*	思路：如果位置上已经有数字了，则跳过，如果没有数字（初始为0），则计算此位置的横排，竖排，和所处宫位的数据，计算出可能在此位置上的数据
	*	
	*/
	clearData:function(){
		for(var x = 0; x < 9; x++){
			var row = this.getArr(x, this._H);
			for(var y = 0; y < 9; y++){
				var col = this.getArr(y,this._V);
				var z =Math.floor(x/3)*3 + Math.floor(y/3);
				var tm = this.getArr(z,this._T);
				var value = this.cols[x][y];
				if(value>10||value==0){
					this.cols[x][y] = this.getMaybe(row, col, tm);
				}
			}
		}
	},
	//简单的单排/列/单宫排除 (算法，打出一排/列/宫所有大于10的数，并相加（字符串形式），如果一个数字只出现了一次，则可确定公位置，如（ 149  134  7  468  1489  5  14  348  2）相加 得149134468148914348，6只出现了一次，则可以确认有6的位置肯定是6)
	//，如果已经排除出一个，则再重算，得得149134148914348，6只出现了一次，则可以确认有6的位置肯定是6，没有独立的数字并与之前的结果一致后，搁置
	//说明 ：不知道怎么办，一共要执行9*3=27次，执行顺充序的先后也会影响最终结果给出来的计算次数，目前不知道怎么做到减少这些次数，暂且为每次编译一横一竖一宫吧。（这样代码会少一点，性能不见得好，个人觉得从中间到两边顺序的排除可能会更给力点，不曾证实）
	setSingleData:function(){
		for(var i=0;i<9;i++){
			this.setSingleX(i);
			this.setSingleY(i);
			this.setSingleZ(i);
		}
	},

	setSingleX:function(pos,this){
		var arr = this.getArr(pos,this._H);
		var oldstr= arr.join('');
		var sureValue = this.getSingleValue(arr).split('');
		var sureSize = sureValue.length;
		if(sureSize>0){
			for(var i=0;i<9;i++){
				for(var j=0;j<sureSize;j++){
					if(arr[i]>10&&arr[i].indexOf(sureValue[j])>=0){
						var x = pos;
						var y =i;
						this.cols[x][y]=sureValue[j];
					}
				}
			}
			var newstr = this.getArr(pos,this._H).join('');
			if(newstr != oldstr){
				this.resetMayBe(pos,,this._H);
				// this.setSingleX(pos,this);
			}
		}
	},
	setSingleY:function(pos,this){
		var arr = this.getArr(pos,this._V);
		var sureValue = this.getSingleValue(arr).split('');
		var sureSize = sureValue.length;
		if(sureSize>0){
			for(var i=0;i<9;i++){
				for(var j=0;j<sureSize;j++){
					if(arr[i]>10&&arr[i].indexOf(sureValue[j])>=0){
						var x = i;
						var y =pos;
						this.cols[x][y]=sureValue[j];
					}
				}
			}
		}
	},
	setSingleZ:function(pos,this){
		var arr = this.getArr(pos,this._T);
		var sureValue = this.getSingleValue(arr).split('');
		var sureSize = sureValue.length;
		if(sureSize>0){
			for(var i=0;i<9;i++){
				for(var j=0;j<sureSize;j++){
					if(arr[i]>10&&arr[i].indexOf(sureValue[j])>=0){
						var h=Math.floor(pos/3);
						var v=pos%3;
						var starth=h*3;
						var startv=v*3;
						var x=starth+Math.floor(i/3);
						var y=startv+i%3;
						this.cols[x][y]=sureValue[j];
					}
				}
			}
		}
	},
	getSingleValue:function(arr){
		var numberstr = '',rtn='';
		for(var i=0,j=arr.length;i<j;i++){
			if(arr[i]>10){
				numberstr+=arr[i];
			}
		}
		for(var i=1;i<=9;i++){
			var s=''+i;
			var start = numberstr.indexOf(s);
			if(start!=-1&&start==numberstr.lastIndexOf(s)){
				rtn+=s;
			}
		}
		return rtn;
	},
	/**
	*	简单推导：根据横竖向的两个宫的两条已知数据进行推导。
	*/
	deduce:function(){

	},
	//此位置上可能的数据，将三围（横竖宫）上所有已经的数据T掉，及为可能数据
	getMaybe:function(row,col,tm){
		var exclude=[];maybe=[];
		for(var i=0;i<9;i++){
			if(row[i]<10&&row[i]>0) exclude.push(row[i]);
			if(col[i]<10&&col[i]>0) exclude.push(col[i]);
			if(tm[i]<10&&tm[i]>0) exclude.push(tm[i]);
		}
		for(var i=1;i<=9;i++){
			if(exclude.indexOf(i)==-1){
				maybe.push(i);
			}
		}
		return maybe.join('');
	},
	resetMayBe:function(index,type){
		var arr=this.getArr(index,type);
	}
	init:function(coords){
		this.cols=coords;
		for(var i=0;i<9;i++){
			this._defaultcols.push(coords.slice(0));
			// var tran = [];
			// for(var j=0;j<9;j++){
			// 	tran.push(''+coords[i][j]);
			// }
			// this.cols.push(tran);
		}
	},
	getArr:function(index,type){
		switch(type){
			case this._H:
				return this.cols[index];
			case this._V:
				var varr =[
						this.cols[0][index],
						this.cols[1][index],
						this.cols[2][index],
						this.cols[3][index],
						this.cols[4][index],
						this.cols[5][index],
						this.cols[6][index],
						this.cols[7][index],
						this.cols[8][index]
				];
				return varr;
			case this._T:
				var h=Math.floor(index/3);
				var v=Math.floor(index%3);
				var starth=h*3;
				var startv=v*3;
				var tarr =[
					this.cols[starth][startv],
					this.cols[starth][startv+1],
					this.cols[starth][startv+2],
					this.cols[starth+1][startv],
					this.cols[starth+1][startv+1],
					this.cols[starth+1][startv+2],
					this.cols[starth+2][startv],
					this.cols[starth+2][startv+1],
					this.cols[starth+2][startv+2]
				];
				return tarr;
		}
	},
	showResult:function(){
		var msg = '';
		var style =[];
		for(var x=0;x<9;x++){
			for(var y=0;y<9;y++){
				msg+='  %c'+this.cols[x][y];
				style.push(this._defaultcols[x][y]?'\'color:black;\'':'\'color:green;\'')
			}
			msg+='\\n';
		}
		window.eval('console.warn(\'' + msg + '\',' +style.join(',')+ ');');
	}
}

var arr=[
	[0,0,7,0,0,5,0,0,2],
	[0,8,6,0,3,0,9,0,0],
	[0,5,0,0,7,0,0,0,0],
	[0,0,4,0,0,8,0,0,0],
	[8,9,0,0,0,0,0,7,5],
	[0,0,0,1,0,0,3,0,0],
	[0,0,0,0,2,0,0,6,0],
	[0,0,8,0,6,0,7,1,0],
	[3,0,0,9,0,0,8,0,0]
];
var sudoku = new Sudoku(arr);
sudoku.reckon();
</script>
</html>